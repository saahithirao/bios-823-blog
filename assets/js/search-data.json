{
  
    
        "post0": {
            "title": "Creating Effective Visualizations about Malaria",
            "content": "The goal of this blog post is to create and explain three effective visualizations about Malaria incidence and deaths using the datasets fron the github repository linked above. Seaborn and plotly libraries will be used to create both static and interactive plots. . import matplotlib.pyplot as plt import pandas as pd import plotly.express as px import plotly.offline as offline from plotly.offline import iplot import seaborn as sns . The first step is to read in the data and explore the observations and variables in the datasets. The first thing I noticed was that the rows represented countries, but there were several rows that were not countries (did not have a country code) in all the datasets. I thought these observations would be interesting to explore because they aggregate the data in a way that would be suitable to visualize. I also renamed some columns for ease of use later on. . url_inc = &#39;https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2018/2018-11-13/malaria_inc.csv&#39; url_deaths = &quot;https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2018/2018-11-13/malaria_deaths.csv&quot; url_deaths_age = &quot;https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2018/2018-11-13/malaria_deaths_age.csv&quot; df_inc = pd.read_csv(url_inc) df_deaths = pd.read_csv(url_deaths) df_deaths_age = pd.read_csv(url_deaths_age) . df_deaths = df_deaths.rename(columns= {&#39;Deaths - Malaria - Sex: Both - Age: Age-standardized (Rate) (per 100,000 people)&#39;: &#39;Deaths&#39;}) df_inc = df_inc.rename(columns= {&quot;Incidence of malaria (per 1,000 population at risk) (per 1,000 population at risk)&quot;: &quot;Incidence&quot;}) . df1 = (df_inc[df_inc.Code.isnull()]. groupby(&quot;Entity&quot;) ) df1.head() . Entity Code Year Incidence . 112 Early-demographic dividend | NaN | 2000 | 83.670771 | . 113 Early-demographic dividend | NaN | 2005 | 61.607992 | . 114 Early-demographic dividend | NaN | 2010 | 47.521445 | . 115 Early-demographic dividend | NaN | 2015 | 28.895022 | . 116 East Asia &amp; Pacific | NaN | 2000 | 22.736116 | . ... ... | ... | ... | ... | . 431 Sub-Saharan Africa (excluding high income) | NaN | 2015 | 234.292105 | . 472 Upper middle income | NaN | 2000 | 8.998182 | . 473 Upper middle income | NaN | 2005 | 6.039381 | . 474 Upper middle income | NaN | 2010 | 3.749804 | . 475 Upper middle income | NaN | 2015 | 3.554438 | . 108 rows × 4 columns . The first plot will explore malaria incidence by region and by income level. I chose to use seaborn for this task because I wanted to create two side-by-side static plots. . This plot illustrates that Sub-Saharn Africa consistently has the highest malaria incidence , but is decreasing over time at a much faster rate than the other world regions. Comparing the region plot to the income plot, we see that lower income levels have higher incidence rates. Also, East Asia and Pacific and Latin America and the Caribbean have similar incidence rates as countries with a high-income level. . region = [&quot;East Asia &amp; Pacific&quot;, &quot;South Asia&quot;, &quot;Sub-Saharan Africa&quot;, &quot;Latin America &amp; Caribbean&quot;] income = [&quot;Low income&quot;, &quot;Middle income&quot;, &quot;Lower middle income&quot;, &quot;Upper middle income&quot;] df_region = df_inc[df_inc.Entity.isin(region)] df_income = df_inc[df_inc.Entity.isin(income)] fig, ax = plt.subplots(1, 2, figsize=(17,5), sharey=True) g = sns.lineplot( data = df_region, x = &#39;Year&#39;, y = &#39;Incidence&#39;, hue = &#39;Entity&#39;, ax = ax[0] ) g.set(xlabel =&quot;Year&quot;, ylabel = &quot;Incidence of Malaria (per 1,000 population at risk)&quot;, title =&#39;Malaria Incidence by Region&#39;) g2 = sns.lineplot( data = df_income, x = &#39;Year&#39;, y = &#39;Incidence&#39;, hue = &#39;Entity&#39;, ax = ax[1], palette=&quot;Blues_r&quot; ) g2.set(xlabel =&quot;Year&quot;, ylabel = &quot;&quot;, title =&#39;Malaria Incidence by Income Level of Countries&#39;) plt.show() . I wanted to create a map, so I needed the data to be aggregated by continents. Using a crosstable with country codes and continent values, I merged the incidence dataset with the crosstable using the country codes. I then, subset the data to Africa to view change in incidence over time among African countries. . I chose to use the plotly library, because I wanted to make an interactive plot and plotly works well for this task. First, I created a dataset for each year in the dataset and added each year&#39;s data to a list that will be used to create the slider. The next step was to create the slider. I referenced this blog post to create the slider object https://medium.com/@anikanacey/adventures-in-plotly-an-interactive-choropleth-map-646f6a2f4e3a. Lastly, I created the image (the continent of Africa with countries) for the data to plotted on and used plotly&#39;s offline module to call the plot. . url2 = &quot;https://raw.githubusercontent.com/lukes/ISO-3166-Countries-with-Regional-Codes/master/all/all.csv&quot; df_cont = pd.read_csv(url2) df_cont = df_cont[[&quot;name&quot;, &quot;alpha-3&quot;, &quot;region&quot;]] df_cont = df_cont.rename(columns = {&#39;alpha-3&#39;: &#39;Code&#39;}) . df_map = (df_inc[df_inc.Code.notnull()]) df_africa = pd.merge(df_map, df_cont, how=&quot;left&quot;, on=&quot;Code&quot;) df_africa = df_africa.loc[df_africa[&#39;region&#39;]== &quot;Africa&quot;] . slider_data = [] year_steps = [] for year in df_africa[&#39;Year&#39;].unique(): df_year = df_africa.loc[df_africa[&#39;Year&#39;] == year] df_year = df_year.astype(str) one_year = dict( type=&#39;choropleth&#39;, locations = df_year[&#39;name&#39;], z=df_year[&#39;Incidence&#39;].astype(float), locationmode=&#39;country names&#39;, colorscale = &quot;oranges&quot;, colorbar= {&#39;title&#39;:&#39;Malaria Incidence (per 1,000 population at risk)&#39;}) slider_data.append(one_year) for i in range(len(slider_data)): step = dict(method=&#39;restyle&#39;, args=[&#39;visible&#39;, [False] * len(slider_data)], label=&#39;{}&#39;.format(5*i + 2000)) step[&#39;args&#39;][1][i] = True year_steps.append(step) sliders = [dict(active=0, pad={&quot;t&quot;: 1}, steps=year_steps)] layout = dict(title =&#39;Incidence of Malaria in Africa since 2000&#39;, geo=dict(scope=&#39;africa&#39;, showcountries = True, projection={&#39;type&#39;: &#39;equirectangular&#39;}), sliders=sliders) fig_africa = dict(data=slider_data, layout=layout) offline.iplot(fig_africa, show_link = True) . This third and final plot illustrates deaths from Malaria by continent over time. I once again used the crosstable with country codes and continents to aggregate the deaths dataset by continent. . df2_deaths = df_deaths[df_deaths.Code.notnull()] df_combine = pd.merge(df2_deaths, df_cont, how=&quot;left&quot;, on=&quot;Code&quot;) df_combine = df_combine.dropna() . fig_cont = px.area(df_combine, x=&quot;Year&quot;, y=&quot;Deaths&quot;, color=&quot;region&quot;, line_group=&quot;name&quot;, labels={ &quot;region&quot;: &quot;Continent&quot;, &quot;Deaths&quot;: &quot;Deaths (per 100,000 people)&quot; }, title=&quot;Deaths from Malaria by Continent over Time&quot;) fig_cont.update_layout( autosize=False, width=900, height=700) offline.iplot(fig_cont) .",
            "url": "https://saahithirao.github.io/bios-823-blog/2021/10/01/visualizations.html",
            "relUrl": "/2021/10/01/visualizations.html",
            "date": " • Oct 1, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Number theory and a Google recruitment puzzle",
            "content": "There are three main steps to this question. 1) Generate an arbitrary large expansion of a mathematical expression 2) Check if a number is prime 3) Generate sliding windows of a specified width from a long iterable . We will start with the first step. The goal is to return an arbitrary expansion (expansion after the decimal) of a mathematical expression. The user inputs will be the mathematical expression along with the multiplier (can be 1) and the number of digits of the expansion. . I first tried using the decimal library to expand the mathematical expression &quot;pi&quot;, but I realized I was approximating pi by using the expression &quot;355/113&quot; and I could not find a more accurate way to expand pi, so I opted to use the sympy library. I used the decimal library to expand &quot;e&quot;. . One important thing to note is that a multiplier of the mathematical expression can be an input like &quot;2e&quot; or &quot;3pi&quot;. The multiplier must be a separate input from the expression. . from decimal import * from sympy import * def expansion(multiplier, expression, n): &quot;&quot;&quot; Input: mathematical expression, a multiplier of the expression, and number of digits of prime number Behavior: expands mathematical expression Output: an arbitrary expansion (specified by user) of a mathematical expressions pi or e &quot;&quot;&quot; if expression == &quot;pi&quot;: # N function captures number of digits, so use log formula to capture number of specified digits after decimal x = N(multiplier*pi, n + log(multiplier*pi, 10) + 1) # obtain digits after decimal and return as integer # integers that start with 0 will not capture the 0 before, after = str(x).split(&#39;.&#39;) return int(after) if expression == &quot;e&quot;: # set number of digits for expansion getcontext().prec = n x = (Decimal(1).exp())*multiplier before, after = str(x).split(&#39;.&#39;) return int(after) # can only generate expansions of pi and e else: return &quot;Can not solve&quot; . The next step is to determine if a number is prime. To make this function efficient, we can loop through divisors in the range from 2 to the square root of the number rounded up using the ceiling function from the math module and check whether that number is a factor. The mathematical intution behind this is that a number that is not prime will have at least one factor that is less than its square root (and one factor greater). So, if a number has no factors less than its square root, it must be prime. For example, let&#39;s take the number 11. The square root of 11 rounded up is 4, so the loop will run from 2 to 4. If there are no factors in that range, that 11 is prime, which is the case. I used this mathematical intuition because looping through all numbers in the range to the specified number is very inefficient, especially because we are working with such large numbers in this question. . from math import sqrt, ceil def prime_num(n): &quot;&quot;&quot; Input: number Behavior: returns true if number is prime Output: true or false &quot;&quot;&quot; # prime numbers have to be greater than 1 if n &gt; 1: # loop through numbers in range 2 to the ceiling of the square root of the specified number for number in range(2, ceil(sqrt(n))): # return to outer for loop and increment by one if input number is not divisible by number if (n % number) == 0: # number is not prime (divisible by a number other than one and itself) return False else: # number is prime, so return true return True else: # return false if number is not greater than 1 return False . The next step is to write the final helper function. The goal is to generate sliding windows of a specified width from a long iterable. . I tried a lot of different things to generate sliding windows including using itertools, but decided that using list comprehensions would be equally succinct in accomplishing this task. . First, we will make the iterable (input number) into a list of its digits as strings. For example, 1234 becomes [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;]. Then, we will create a window of a specified size for each element (digit) in the range of the number until a window of the specified size cannot be made. For example, if we want a window of size 3, we will loop through all the elements in range of the length of the list of digits minus the size of the window plus one. So, using our example, the loop will run from &#39;1&#39; to &#39;2&#39;. For each iteration, the window will be appeneded as a list to a list of windows. So, from our example, [[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;],[&#39;2&#39;,&#39;3&#39;,&#39;4&#39;]] will be the output from the loop. Next, we want to return a list of integers, so we will combine the digits into one number and convert to an integer. From our example, the output would be [123, 234]. . def sliding_window(iterable, size): &quot;&quot;&quot; Input: integer and size of window Behavior: generates sliding windows of a specified width from a long iterable Output: list of windows &quot;&quot;&quot; window_list = [] # length of number has to be greater than the window size if len(str(iterable)) &gt;= size: # make iterable into list of its digits it_list = [str(x) for x in str(iterable)] # create window as a list by grabbing elements in range of current element through the elements in the window size windows = [it_list[x:x+size] for x in range(len(it_list) - size + 1)] # convert list of digits in window to a single integer and append to list for window in windows: a_string = &quot;&quot;.join(window) an_integer = int(a_string) window_list.append(an_integer) # returns list of integers return window_list else: return &quot;Size of window bigger than iterable&quot; . The final step is to create a function with these helper functions to return a specified digit-length prime in the decimal expansion of a mathematical expression like &quot;pi&quot;. First, we will create the decimal expansion using the expansion helper function. Then, we will create the list of sliding windows given the size of the prime number we want using the sliding windows helper function. Finally, we will check whether each number in each window is prime using the prime helper function and return the first prime number. . def prime_expanded_expression(size, multiplier, expression, digits): &quot;&quot;&quot; Input: size of window, multiplier of expression, mathematical expression, and number of digits to expand Behavior: returns a specified digit-length prime in the decimal expansion of a mathematical expression Output: number &quot;&quot;&quot; # create decimal expansion of mathematical expression expanded = expansion(multiplier, expression, digits) # create list of sliding windows of decimal expansion given size of window expansion_window = sliding_window(expanded, size) # check whether each window (number) is a prime and if it is, return that number for number in expansion_window: # numbers that are less than a length of 10 start with 0, so cannot be prime if len(str(number)) == 10: # check whether number is prime if prime_num(number): return number . Now, we will write unit tests for each function to assert that they are returning the correct values and to check edge cases. Two tests are written for each function. . import unittest class TestNotebook(unittest.TestCase): def test_expansion(self): &quot;&quot;&quot;test expansion.&quot;&quot;&quot; self.assertEqual(expansion(1, &quot;pi&quot;, 5), 14159) self.assertEqual(expansion(17, &quot;pi&quot;, 9), 407075111) def test_prime_num(self): &quot;&quot;&quot;test prime_num.&quot;&quot;&quot; self.assertFalse(prime_num(1)) self.assertTrue(prime_num(4159)) def test_sliding_window(self): &quot;&quot;&quot;test sliding_window.&quot;&quot;&quot; self.assertEqual(sliding_window(407075111, 4), [4070, 707, 7075, 751, 7511, 5111]) self.assertEqual(sliding_window(1234, 5), &quot;Size of window bigger than iterable&quot;) def prime_expanded_expression(self): &quot;&quot;&quot;test prime_expanded_expression.&quot;&quot;&quot; self.assertEqual(prime_expanded_expression(10, 1, &quot;e&quot;, 110), 7427466391) self.assertEqual(prime_expanded_expression(4, 1, &quot;pi&quot;, 110), 4159) unittest.main(argv=[&#39;&#39;], verbosity=2, exit=False) . test_expansion (__main__.TestNotebook) test expansion. ... ok test_prime_num (__main__.TestNotebook) test prime_num. ... ok test_sliding_window (__main__.TestNotebook) test sliding_window. ... ok - Ran 3 tests in 0.015s OK . &lt;unittest.main.TestProgram at 0x7f210dc81650&gt; . Finally, let&#39;s solve the problem! The first 10-digit prime in the decimal expansion of 17π is 8649375157. . print(prime_expanded_expression(10, 17, &quot;pi&quot;, 110)) . 8649375157 .",
            "url": "https://saahithirao.github.io/bios-823-blog/2021/09/17/numbertheory.html",
            "relUrl": "/2021/09/17/numbertheory.html",
            "date": " • Sep 17, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Solving three problems from the Euler Project (with increasing difficulty)",
            "content": "Problem 5: Smallest Multiple . Description: 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder. What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20? . After reading this question, I immediately thought about prime factorization and factor trees. The goal is to program a factor tree and work backwards from the prime factors to calculate the smallest number that is evenly divisible by all numbers from 1 to 20. Note that 2520 has to be divisible by the prime numbers from 1 to 10 in order to be divisible by all numbers 1 to 10 without any remainder. Knowing this, we can save time by not checking whether 2520 is divisible by every number from 1 to 10. . So to begin, we will define a function to return a list of all the prime numbers from 1 to a given number. This will help us code our factor tree. . def prime_num(n): &quot;&quot;&quot; return list of prime numbers given a number &quot;&quot;&quot; primes = [] # prime numbers have to be greater than 1 for number in range(2, n + 1): for i in range(2, number): if (number % i) == 0: # number is not prime (divisible by a number other than one and itself) # return to outer for loop and increment by one break else: # number is prime so add to list primes.append(number) return primes . Next, the goal is to code a factor tree where the &quot;ends&quot; or what is returned are all the prime factors of the given number. . We will find the prime factors of this given number (n) using knowledge about whether a number is prime in range 1 to n from the above function that returns the prime numbers in range 1 to n. Recursion works well here because we want to break down n into smaller parts each time until n equals 1 and we cannot find any more prime factors. . def find_prime_factors(n): &quot;&quot;&quot; recursively find prime factors of number given prime numbers in range 1 to that number &quot;&quot;&quot; prime_numbers = prime_num(20) if n == 1: # base case: if n = 1, there are no more prime factors return [] for num in prime_numbers: # loop through each number in the list of prime numbers in range 1 to n if n % num == 0: # return the prime factor and use recursion to find next prime factor return [num] + find_prime_factors(n / num) . We will write a final function that uses the two functions we have written. We know the prime numbers from 1 to a given number from the first function. We can also find the prime factors of a number from the second function. . Now, we will find the prime factors of every number 20 and below (using the second function). We will keep track of the maximum prime factors. For example, the prime factors of 2 and 3, respectively, are 2 and 3 and the prime factors of 4 are 2 and 2. So, the maximum count of the prime factor 2 is 2 and of 3 is 1 and the prime factors of the smallest number evenly divisible by 2, 3, and 4, are 2, 2, and 3 and NOT 2, 3, 2, and 2. This means the smallest number evenly divisible by 2, 3, and 4 equals (2)(2)(3) = 12. . Using this same logic, we will use the maximum prime factors of numbers 20 and below to calculate the smallest number evenly divisible by all of the numbers from 1 to 20. . We recently reviewed the collections module, so we will use that to count the maximum number of each prime factor. . from collections import Counter def main(): &quot;&quot;&quot; print smallest number evenly divisible by all numbers from 1 to 20 &quot;&quot;&quot; max_primes = Counter() for i in range(2, 21): # creating a factor tree for each number from 2 to 20 prime_factors = Counter(find_prime_factors(i)) # keeps maximum of counts of each prime factor max_primes = prime_factors | max_primes smallest_num = 1 for prime, count in max_primes.items(): # based on prime factors, calculate smallest number by multiplying smallest_num = smallest_num * (prime ** count) print(smallest_num) main() . 232792560 . The smallest positive number that is evenly divisible by all of the numbers from 1 to 20 is 232792560. . Problem 39: Integer Right Triangles . Description: If p is the perimeter of a right angle triangle with integral length sides, {a,b,c}, there are exactly three solutions for p = 120. {20,48,52}, {24,45,51}, {30,40,50} For which value of p ≤ 1000, is the number of solutions maximised? . This question involves pythagorean theorem (a^2 + b^2 = c^2). The first step is to define a function that returns the number of solutions that meet the right angle triangle side length definition given a perimeter. . We know that a and b have to be at least 1 and cannot be more than half the perimeter. So, we will use a to loop through all integers from 1 to p/2. . Given these two equations: a^2 + b^2 = c^2 (pythagorean theorem) a + b + c = p (definition of perimeter) . We can solve for b and c. 1) a + b + c = p --&gt; b+c = p-a 2) a^2 + b^2 = c^2 --&gt; c-b = a^2/(p-a) 3) (c-b) + (c+b) = a^2/(p-a) + (p-a) --&gt; c = (a^2 + (p-a)^2)/(2 *(p-a) . Then, using pythagorean theorem, b = sqrt(c^2 - a^2) . The final step is to check whether the definition of perimeter is met and make sure we have the correct value for a. . def find_side_lengths(p): &quot;&quot;&quot; return number of solutions that meet the definition of right angle triangle side lengths given a perimeter &quot;&quot;&quot; num_solutions = 0 # an integer side length of a right triangle has to be at least 1 and not more than half the perimeter for a in range(1, p//2): # solve pythagorean theorem for c and b c = (a**2 + (p-a)**2) // (2 * (p-a)) b = (c**2 - a**2) ** 0.5 # if definition of perimeter is met, increment solutions by one if a + b + c == p: num_solutions += 1 # a and b can be switched in a solution, but we only want one solution of possible integral side lengths return num_solutions//2 . Next, we want to find the perimeter where the number of solutions, given that we know the number of solutions for a perimeter from the previous equation, is maximized for perimeters ≤ 1000. We will use a dictionary to store the perimeter and the number of solutions for that perimeter. . def maximized(perimeter): &quot;&quot;&quot; print perimeter where the number of solutions is maximized for perimeter &lt;= 1000 &quot;&quot;&quot; data = {&quot;perimeter&quot;: 0, &quot;solutions&quot;: 0} # store perimeter value and number of solutions for p in range(perimeter + 1): # if the number of solutions of the current perimeter is greater than the solutions for all perimeters smaller # then store that perimeter and the corresponding number of solutions solutions = find_side_lengths(p) if solutions &gt; data[&#39;solutions&#39;]: data[&#39;solutions&#39;] = solutions data[&#39;perimeter&#39;] = p return data[&#39;perimeter&#39;] print(maximized(1000)) . 840 . The number of solutions is maximised at a perimeter of 840. . Problem 112: Bouncy Numbers . Decription: Working from left-to-right if no digit is exceeded by the digit to its left it is called an increasing number; for example, 134468. . Similarly if no digit is exceeded by the digit to its right it is called a decreasing number; for example, 66420. . We shall call a positive integer that is neither increasing nor decreasing a &quot;bouncy&quot; number; for example, 155349. . Clearly there cannot be any bouncy numbers below one-hundred, but just over half of the numbers below one-thousand (525) are bouncy. In fact, the least number for which the proportion of bouncy numbers first reaches 50% is 538. . Surprisingly, bouncy numbers become more and more common and by the time we reach 21780 the proportion of bouncy numbers is equal to 90%. . Find the least number for which the proportion of bouncy numbers is exactly 99%. . The first step is to determine if a number is bouncy. Using the properties of a bouncy number, that it is neither increasing nor decreasing, we will define a function that returns true if the number is bouncy. . def bouncy(n): &quot;&quot;&quot; return true if the number is bouncy and false otherwise &quot;&quot;&quot; number = list(map(int, str(n))) # list of digits increasing = sorted(number) # if number is sorted, it is increasing decreasing = increasing[::-1] # if number is sorted in reverse, it is decreasing return increasing != number and decreasing != number . Next, we will find the least number for which the proportion of bouncy numbers is exactly 99%. . I found that a while loop would work well in this case because we want the loop to run until we find the number when the proportion equals 99%. Each iteration we will check whether the number is bouncy and whether the proportion of bouncy numbers equals 99% beginning at 100. . def prop_bouncy(): &quot;&quot;&quot; return least number where the proportion of bouncy numbers that is exactly 99% &quot;&quot;&quot; total = 100 # no bouncy numbers below 100 bouncy_n = 0 # continue finding bouncy numbers until proportion hits 99% while bouncy_n / total != 0.99: # determine if number is bouncy then increment count by one if is bouncy if bouncy(total) is True: bouncy_n += 1 # if proportion is eactly 99%, return number if bouncy_n / total == 0.99: return total # increment total to continue finding least number else: total += 1 print(prop_bouncy()) . 1587000 . The least number for which the proportion of bouncy numbers is exactly 99% is 1587000. .",
            "url": "https://saahithirao.github.io/bios-823-blog/2021/09/03/eulerproblems.html",
            "relUrl": "/2021/09/03/eulerproblems.html",
            "date": " • Sep 3, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://saahithirao.github.io/bios-823-blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://saahithirao.github.io/bios-823-blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://saahithirao.github.io/bios-823-blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://saahithirao.github.io/bios-823-blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}